# -*- coding: utf-8 -*-
"""CS350 Biomedical Computation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uHi3Bf3T2s80xVswKiR1sm3VmCfbWAdX

Material taught from Bioinformatics Algorithms by Phillip Compeau, some functions are based on pseudocode found in the text
All code is written by Michael Taylor

Ch. 1: Finding Origins of Replications (OriC)
"""

def substring(text, i, k):
  return text[i:i+k]12+2


# Returns int:count of occurences of str:pattern in str:genome
#Complexity: O(n)
def patternCount(genome, pattern):
  count = 0
  for i in range(len(genome) - len(pattern)):
    if substring(genome, i, len(pattern)) == pattern:
      count = count + 1
  return count

genes = "AAAGGGTTTCCCAATTAA"
print(patternCount(genes, "AA"))


# Returns list of most frequent patterns of int:k length in str:genome 
# Complexity: O(n^2)
def freqWords(genome, k):
  freqPatts = []
  counts = []
  for i in range(len(genome) - k): #O(n)
    pattern = genome[i:i+k]
    counts.append(patternCount(genome, pattern)) # O(n) function called O(n) times -> O(n^2)
  
  maxCount = max(counts)

  for i in range(len(genome) - k): #O(n)
    if counts[i] == maxCount:
      freqPatts.append(genome[i:i+k])
  return list(set(freqPatts))

# Returns dict of most frequent patterns of int:k length in str:genome 
def freqTable(genome, k):
  freqMap = {}
  n = len(genome)
  for i in range(n-k):
    pattern = genome[i:i+k]
    
    freqMap.setdefault(pattern, 0)

    if freqMap[pattern] >= 1:
      freqMap[pattern] = freqMap[pattern] + 1
    else:
      freqMap[pattern] = 1
  return freqMap

# Takes in map/dict & returns highest value
def maxMap(mapStrings):
  return mapStrings.get(max(mapStrings, key=mapStrings.get))

def freqWordsPlus(genome, k):
  freqPatts = []
  freqMap = freqTable(genome, k)
  maxVal = maxMap(freqMap) # max num of pattern occurences in genome 
  for kmer in freqMap.keys():
    if freqMap.get(kmer) == maxVal:
      freqPatts.append(kmer)
  
  return freqPatts

# Prints list of most frequent k-mers through lengths minK to maxK
def makeKmerTable(genome, minK, maxK):
  for i in range(minK, maxK + 1):
    freqTable = freqWordsPlus(genome, i)
    print(" ")
    print("frequent k-mers of length k = " + str(i) + ", count = " + str(len(freqTable)))
    print(freqTable)
    print(" ")
    print("_______________________________________________________________")

# outputs the reverse complementary strand of the given DNA string
def reverseDNA(genome):
  dnaPairings = {
      "A": "T",
      "T": "A",
      "G": "C",
      "C": "G"
  }
  backwardsDNA = DNA[::-1]
  complementaryStrand = ""
  for nucleotide in backwardsDNA.upper():
    complementaryStrand += dnaPairings.get(nucleotide)
  return complementaryStrand

# Returns a collection of space-separated integers specifying all starting positions where Pattern appears as a substring of Genome
def findPatternPositions(pattern, genome):
  #indices = []
  indicesStr = ""
  for i in range(len(genome) - len(pattern)):
    if genome[i:i+len(pattern)] == pattern:
      #indices.append(i)
      indicesStr += str(i) + " "
  return indicesStr


# Finds clumps of k-mers that occur >= t times within range L of each other within genome 
def findClumps(genome, k, L, t):
  patterns = []
  n = len(genome)
  for i in range(n-L):
    window = genome[i:i+L]
    freqMap = freqTable(window, k)
    for kmer in freqMap.keys():
      if freqMap[kmer] >= t:
        patterns.append(kmer)
  patterns = list(set(patterns))
  return patterns

#genomePath = input("Enter path to genome file: ")
#genomeFile = open(genomePath)
#genome = genomeFile.read()

#print(len(findClumps(genome, 9, 500, 3)))
